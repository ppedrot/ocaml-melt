##verbatim '#' = verbatim_code

let verbatim_code x = texttt (Verbatim.verbatim x)

let latex = command \"LaTeX\" [] T
let latexlib = texttt "Latex"
let melt = "Melt"
let meltlib = texttt "Melt"
let ocaml = "OCaml"
let camlp4 = "Camlp4"
let mlpost = textsc "Mlpost"
let postscript = "Postscript"
let pdf = "PDF"

let ie = emph "i.e."

let display x =
  environment \"center\"
    (T, command \"fbox\"
       [T, environment \"minipage\" ~args: [T, text \"0.9\\textwidth\"] (T, x) T]
       T) T

let listing = display

let doc = ("
{section "Introduction"}

{subsection "What is {melt}?"}

{paragraph "Motivation"}

{latex} is great to format text. {ocaml} is great to program.
What if you want to program {latex} documents using the {ocaml} syntax
and type system? Then you can use {melt}. Let's see how we can
produce the following:
      {display "Let $X {subset} \{1, 2, 3\}$."}
      With {latex}, this is easy:
      {display "<#Let $X \subset \{1, 2, 3\}$.#>"}
      What does it mean to program this in {ocaml}? Let's assume that
you have some {latexlib} library providing the following functions:
<#t#> which converts a string to {latex} text,
<#m#> which converts a string to {latex} math,
some basic {latex} macros and
<#c#> which concatenates a list of {latex} expressions.
Our example may then be encoded like this:
      {display "<#c [ t "Let "; m "X"; subset; lbrace; m "1, 2, 3"; rbrace;
    t "." ]#>"}
      This is much more verbose than the original {latex} code!
      The {melt} pre-processor allows lighter syntax:
      {display "<#"Let $X {subset} \{1, 2, 3\}$."#>"}
      Note how close this is to the {latex} syntax. The main differences
are: usage of double quotes to enter {emph "text"} mode and usage of
braces to enter {emph "code"} mode. The code mode, here, is used
for command <#subset#>, which is an {ocaml} value of {latex} type.

{paragraph "What is {melt}?"}

{melt} allows you to write {latex} documents using {ocaml}.
It is composed of the {latexlib} library for {ocaml},
the {melt} preprocessor,
the {melt} tool,
and the {meltlib} library.

The {latexlib} library provides an {ocaml} interface to {latex}. It allows to
create {latex} values in text or math mode and to concatenate them. It defines
basic {latex} commands, such as <#\subset#>, as {ocaml} values.

It is possible to write an entire document using only the {latexlib} library,
but the syntax of {ocaml} is awful for this purpose, and the document quickly
becomes an awful, unreadable mess. The {melt} preprocessor provides a much
lighter syntax, allowing the user to easily interleave {latex} values and
{ocaml} code.

The {melt} tool takes a {melt} program and compiles it into a {postscript} or
a {pdf} document. It runs the preprocessor if needed, compiles the program,
executes it to produce a {latex} program, and then runs {latex} to produce
the final document.

The {meltlib} library contains various tools to glue things together. In
particular, it contains functions to easily include {mlpost} pictures.

{subsection "Getting Started"}

A basic {melt} program, <#hello.mlt#>, looks like this:
{listing "<#emit (document "Hello, world!")#>"}
Let's see how to compile this document, and how does it work.

{paragraph "Compiling Using the {melt} Tool."}

You can compile <#hello.mlt#> in one command using the {melt} tool:
{listing "<#melt hello.mlt#>"}
This produces a file <#hello.ps#> containing the text ``Hello, world!''.
You can produce a {pdf} file instead, using the <#-pdf#> option.

{paragraph "Compiling by Hand."}

Instead of using the {melt} tool, you can apply the preprocessor yourself:
{listing "<#meltpp hello.mlt -o hello.ml -open Latex -open Melt#>"}
This produces a file <#hello.ml#> which looks like this:
{listing "<#open Latex;;
open Melt;;
emit (document (mode T ((text "Hello, world!"))))#>"}
As you can see, the string <#"Hello, world!"#> is no longer a string but a
value of type <#Latex.t#>. You can them compile this {ocaml} program.
Once executed, it will produce a file <#hello.tex#> looking like this:
{listing "<#\documentclass{article}
\author{}
\begin{document}
  Hello, world!
\end{document}#>"}
You can compile this file using <#latex#> or <#pdflatex#>.

{paragraph "Understanding the Code."}

The <#emit#> function of the {meltlib} library takes a value of type
<#Latex.t#>. Values of this type describe {latex} abstract syntax trees
(ASTs), {ie}, {latex} programs. The function writes this AST into the
file <#hello.tex#>.

What we want to emit is a full {latex} document. The <#document#> function
of the {latexlib} library takes a body, of type <#Latex.t#>, and returns
another value of type <#Latex.t#>. The returned AST contains the document class,
the <#document#> environment, the author and so on.

To produce the body of the document, we use the {melt} preprocessor. In a
{melt} document, double quotes do not create values of type <#string#>
but values of type <#Latex.t#>. So, here, <#"Hello, world!"#> is not a
<#string#> but a piece of {latex} AST that we can give to the <#document#>
function.

{paragraph "Text and Math Modes."}

You can insert math formula using the dollar delimiters <#$#{cdots}#$#>,
as in {latex}:
{listing "<#"Assume $x+y=42$."#>"}
This will produce:
{display "Assume $x+y=42$."}
The world ``Assume'', as well as the ending dot, are printed in
{emph "text"} mode, whereas the math formula is printed in {emph "math"} mode.
You enter text mode using double quotes <#"#{cdots}#"#>, and you enter math
mode using dollars <#$#{cdots}#$#>. Note that you can enter math mode
directly:
{listing "<#emit (document $x+y=42$)#>"}
You can also enter text mode while in math mode:
{listing "<#$x+y=42 " but " z+t=69$#>"}
This will produce:
{display $x+y=42 " but " z+t=69$}
These modes can be nested arbitrarily, but do not abuse this feature as your
code will become less readable.

{paragraph "Code Mode."}

The third mode is called {emph "code"} mode. It is introduced using round
brackets delimiters <#{#{cdots}#}#>. It allows to insert an {ocaml} value of
type <#Latex.t#>. In particular, this is useful to write macros:
{listing "<#let p = $3.141592$ in
emit (document "{pi} is {p}.")#>"}
This will produce:
{display (let p = $3.141592$ in "{pi} is {p}.")}
<#pi#> is a value of type <#Latex.t#> which is defined in the <#Latex#> module.

In code mode, you can insert {ocaml} code of any complexity:
{listing "<#$1+2+3 = {latex_of_int (1+2+3)}$#>"}
This will produce:
{display $1+2+3 = {latex_of_int (1+2+3)}$}
The code in code mode is also preprocessed. This means that you can nest
code, math and text modes arbitrarily. For example:
{listing "<#"The {emph "code"} mode is emphasized."#>"}
This will produce:
{display "The {emph "code"} mode is emphasized."}

{paragraph "Verbatim Mode."}

The last mode is called {emph "verbatim"} mode. It can be used to insert text
that should not be parsed, such as code listing{footnote
"It is {emph "heavily"} used in the source
of this document, which is of course written using {melt}."}.
Here is an example:
{listing "<#"Code: <<printf "Toto has $%d to spare." 42>>"#>"}
This will produce:
{display "Here is some code: <<printf "Toto has $%d to spare." 42>>"}
As you can see, the code between the <#<<#{cdots}#>>#> delimiters is not
preprocessed: the double quotes and dollars are left as it. Moreover, every
symbol is translated into the latex command <#symbol#> so it
can be printed correctly. Spaces and new lines are also translated. To sum up,
the text you write in verbatim mode will be printed
verbatim{footnote "This is no coincidence."}.

Note that the
<#symbol#> command of {latex} often does not work well unless you use a
<#tt#> font. The above example should be rewritten:
{listing "<#"Code: {texttt "<<printf "Toto has $%d to spare." 42>>"}"#>"}
This will produce:
{listing "Code: {texttt "<<printf "Toto has $%d to spare." 42>>"}"}
Also note that the verbatim mode can only be used in text mode. If you write
<#<<#> in math mode, this will produce $<<$, and in code mode this will produce
a syntax error from the {ocaml} compiler or a quotation if you use the
{camlp4} syntax extension.

The verbatim mode has other features such as delimiter selection,
function selection and
antiquotations. They will be described later in this document.
")

let () = emit (document ~title: "Melt User Manual" ~date: "" doc)
